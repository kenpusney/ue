{"version":3,"sources":["encode.js","deflate.js","History.js","App.js","serviceWorker.js","index.js"],"names":["deflate","require","append3bytes","b1","b2","b3","c2","c3","c4","r","encode6bit","b","String","fromCharCode","module","exports","compress","s","unescape","encodeURIComponent","data","i","length","charCodeAt","encode64","zip_free_queue","zip_qhead","zip_qtail","zip_initflag","zip_outcnt","zip_outoff","zip_complete","zip_window","zip_d_buf","zip_l_buf","zip_prev","zip_bi_buf","zip_bi_valid","zip_block_start","zip_ins_h","zip_hash_head","zip_prev_match","zip_match_available","zip_match_length","zip_prev_length","zip_strstart","zip_match_start","zip_eofile","zip_lookahead","zip_max_chain_length","zip_max_lazy_match","zip_compr_level","zip_good_match","zip_nice_match","zip_dyn_ltree","zip_dyn_dtree","zip_static_ltree","zip_static_dtree","zip_bl_tree","zip_l_desc","zip_d_desc","zip_bl_desc","zip_bl_count","zip_heap","zip_heap_len","zip_heap_max","zip_depth","zip_length_code","zip_dist_code","zip_base_length","zip_base_dist","zip_flag_buf","zip_last_lit","zip_last_dist","zip_last_flags","zip_flags","zip_flag_bit","zip_opt_len","zip_static_len","zip_deflate_data","zip_deflate_pos","zip_WSIZE","zip_STORED_BLOCK","zip_STATIC_TREES","zip_DYN_TREES","zip_DEFAULT_LEVEL","zip_FULL_SEARCH","zip_INBUFSIZ","zip_INBUF_EXTRA","zip_OUTBUFSIZ","zip_window_size","zip_MIN_MATCH","zip_MAX_MATCH","zip_BITS","zip_LIT_BUFSIZE","zip_DIST_BUFSIZE","zip_HASH_SIZE","zip_HASH_MASK","zip_WMASK","zip_NIL","zip_TOO_FAR","zip_MIN_LOOKAHEAD","zip_MAX_DIST","zip_SMALLEST","zip_MAX_BITS","zip_MAX_BL_BITS","zip_LENGTH_CODES","zip_LITERALS","zip_END_BLOCK","zip_L_CODES","zip_D_CODES","zip_BL_CODES","zip_REP_3_6","zip_REPZ_3_10","zip_REPZ_11_138","zip_HEAP_SIZE","zip_H_SHIFT","parseInt","zip_outbuf","zip_DeflateCT","this","fc","dl","zip_DeflateTreeDesc","dyn_tree","static_tree","extra_bits","extra_base","elems","max_length","max_code","zip_DeflateConfiguration","a","c","d","good_length","max_lazy","nice_length","max_chain","zip_DeflateBuffer","next","len","ptr","Array","off","zip_extra_lbits","zip_extra_dbits","zip_extra_blbits","zip_bl_order","zip_configuration_table","zip_reuse_queue","p","zip_head1","zip_head2","val","zip_put_byte","q","zip_new_queue","zip_qoutbuf","zip_put_short","w","zip_INSERT_STRING","zip_SEND_CODE","tree","zip_send_bits","zip_D_CODE","dist","zip_SMALLER","n","m","zip_read_buff","buff","offset","zip_longest_match","cur_match","matchp","chain_length","scanp","best_len","limit","strendp","scan_end1","scan_end","zip_fill_window","more","zip_init_deflate","bits","code","zip_gen_codes","zip_bi_reverse","zip_init_block","zip_ct_init","j","zip_lm_init","zip_deflate_internal","buff_size","zip_qcopy","flush","zip_ct_tally","zip_flush_block","zip_deflate_fast","zip_deflate_better","zip_pqdownheap","k","v","next_code","zip_build_tree","desc","stree","node","xnew","h","xbits","f","extra","base","overflow","zip_gen_bitlen","zip_scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","zip_send_tree","eof","opt_lenb","static_lenb","max_blindex","stored_len","zip_build_bl_tree","zip_bi_windup","zip_compress_block","lcodes","dcodes","blcodes","rank","zip_send_all_trees","lc","dcode","out_length","in_length","ltree","dtree","lx","dx","fx","flag","zip_Buf_size","value","res","str","level","zip_deflate_start","aout","cbuf","join","History","_ref","recover","isto","react_default","createElement","list","map","index","key","onClick","label","App","props","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","onTextChangeUpdate","source","state","img","concat","Date","toLocaleString","setState","onSaveButtonClick","_this$state","ueIsto","push","onRecoverEditingText","objectSpread","top","_this2","className","onChange","event","target","cols","rows","style","width","alt","src","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.652fe281.chunk.js","sourcesContent":["\nconst deflate = require(\"./deflate\");\n\nfunction encode64(data) {\n    var r = \"\";\n    for (var i = 0; i < data.length; i += 3) {\n        if (i + 2 == data.length) {\n            r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0);\n        } else if (i + 1 == data.length) {\n            r += append3bytes(data.charCodeAt(i), 0, 0);\n        } else {\n            r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1),\n                data.charCodeAt(i + 2));\n        }\n    }\n    return r;\n}\n\nfunction append3bytes(b1, b2, b3) {\n    var c1 = b1 >> 2;\n    var c2 = ((b1 & 0x3) << 4) | (b2 >> 4);\n    var c3 = ((b2 & 0xF) << 2) | (b3 >> 6);\n    var c4 = b3 & 0x3F;\n    var r = \"\";\n    r += encode6bit(c1 & 0x3F);\n    r += encode6bit(c2 & 0x3F);\n    r += encode6bit(c3 & 0x3F);\n    r += encode6bit(c4 & 0x3F);\n    return r;\n}\n\nfunction encode6bit(b) {\n    if (b < 10) {\n        return String.fromCharCode(48 + b);\n    }\n    b -= 10;\n    if (b < 26) {\n        return String.fromCharCode(65 + b);\n    }\n    b -= 26;\n    if (b < 26) {\n        return String.fromCharCode(97 + b);\n    }\n    b -= 26;\n    if (b == 0) {\n        return '-';\n    }\n    if (b == 1) {\n        return '_';\n    }\n    return '?';\n}\n\nmodule.exports = {\n    compress: (s) => {\n        //UTF8\n        s = unescape(encodeURIComponent(s));\n        return encode64(deflate(s, 9));\n    }\n}","/*\n * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $\n *\n * Original:\n *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt\n */\n\n// if run as a web worker, respond to messages by deflating them\nvar deflate = (function() {\n\n    /* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n     * Version: 1.0.1\n     * LastModified: Dec 25 1999\n     */\n    \n    /* Interface:\n     * data = deflate(src);\n     */\n    \n    /* constant parameters */\n    var zip_WSIZE = 32768;\t\t// Sliding Window size\n    var zip_STORED_BLOCK = 0;\n    var zip_STATIC_TREES = 1;\n    var zip_DYN_TREES    = 2;\n    \n    /* for deflate */\n    var zip_DEFAULT_LEVEL = 6;\n    var zip_FULL_SEARCH = true;\n    var zip_INBUFSIZ = 32768;\t// Input buffer size\n    var zip_INBUF_EXTRA = 64;\t// Extra buffer\n    var zip_OUTBUFSIZ = 1024 * 8;\n    var zip_window_size = 2 * zip_WSIZE;\n    var zip_MIN_MATCH = 3;\n    var zip_MAX_MATCH = 258;\n    var zip_BITS = 16;\n    // for SMALL_MEM\n    var zip_LIT_BUFSIZE = 0x2000;\n    var zip_HASH_BITS = 13;\n    // for MEDIUM_MEM\n    // var zip_LIT_BUFSIZE = 0x4000;\n    // var zip_HASH_BITS = 14;\n    // for BIG_MEM\n    // var zip_LIT_BUFSIZE = 0x8000;\n    // var zip_HASH_BITS = 15;\n    //if(zip_LIT_BUFSIZE > zip_INBUFSIZ)\n    //    alert(\"error: zip_INBUFSIZ is too small\");\n    //if((zip_WSIZE<<1) > (1<<zip_BITS))\n    //    alert(\"error: zip_WSIZE is too large\");\n    //if(zip_HASH_BITS > zip_BITS-1)\n    //    alert(\"error: zip_HASH_BITS is too large\");\n    //if(zip_HASH_BITS < 8 || zip_MAX_MATCH != 258)\n    //    alert(\"error: Code too clever\");\n    var zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;\n    var zip_HASH_SIZE = 1 << zip_HASH_BITS;\n    var zip_HASH_MASK = zip_HASH_SIZE - 1;\n    var zip_WMASK = zip_WSIZE - 1;\n    var zip_NIL = 0; // Tail of hash chains\n    var zip_TOO_FAR = 4096;\n    var zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;\n    var zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;\n    var zip_SMALLEST = 1;\n    var zip_MAX_BITS = 15;\n    var zip_MAX_BL_BITS = 7;\n    var zip_LENGTH_CODES = 29;\n    var zip_LITERALS =256;\n    var zip_END_BLOCK = 256;\n    var zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;\n    var zip_D_CODES = 30;\n    var zip_BL_CODES = 19;\n    var zip_REP_3_6 = 16;\n    var zip_REPZ_3_10 = 17;\n    var zip_REPZ_11_138 = 18;\n    var zip_HEAP_SIZE = 2 * zip_L_CODES + 1;\n    var zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /\n                   zip_MIN_MATCH);\n    \n    /* variables */\n    var zip_free_queue;\n    var zip_qhead, zip_qtail;\n    var zip_initflag;\n    var zip_outbuf = null;\n    var zip_outcnt, zip_outoff;\n    var zip_complete;\n    var zip_window;\n    var zip_d_buf;\n    var zip_l_buf;\n    var zip_prev;\n    var zip_bi_buf;\n    var zip_bi_valid;\n    var zip_block_start;\n    var zip_ins_h;\n    var zip_hash_head;\n    var zip_prev_match;\n    var zip_match_available;\n    var zip_match_length;\n    var zip_prev_length;\n    var zip_strstart;\n    var zip_match_start;\n    var zip_eofile;\n    var zip_lookahead;\n    var zip_max_chain_length;\n    var zip_max_lazy_match;\n    var zip_compr_level;\n    var zip_good_match;\n    var zip_nice_match;\n    var zip_dyn_ltree;\n    var zip_dyn_dtree;\n    var zip_static_ltree;\n    var zip_static_dtree;\n    var zip_bl_tree;\n    var zip_l_desc;\n    var zip_d_desc;\n    var zip_bl_desc;\n    var zip_bl_count;\n    var zip_heap;\n    var zip_heap_len;\n    var zip_heap_max;\n    var zip_depth;\n    var zip_length_code;\n    var zip_dist_code;\n    var zip_base_length;\n    var zip_base_dist;\n    var zip_flag_buf;\n    var zip_last_lit;\n    var zip_last_dist;\n    var zip_last_flags;\n    var zip_flags;\n    var zip_flag_bit;\n    var zip_opt_len;\n    var zip_static_len;\n    var zip_deflate_data;\n    var zip_deflate_pos;\n    \n    /* objects (deflate) */\n    \n    function zip_DeflateCT() {\n        this.fc = 0; // frequency count or bit string\n        this.dl = 0; // father node in Huffman tree or length of bit string\n    }\n    \n    function zip_DeflateTreeDesc() {\n        this.dyn_tree = null;\t// the dynamic tree\n        this.static_tree = null;\t// corresponding static tree or NULL\n        this.extra_bits = null;\t// extra bits for each code or NULL\n        this.extra_base = 0;\t// base index for extra_bits\n        this.elems = 0;\t\t// max number of elements in the tree\n        this.max_length = 0;\t// max bit length for the codes\n        this.max_code = 0;\t\t// largest code with non zero frequency\n    }\n    \n    /* Values for max_lazy_match, good_match and max_chain_length, depending on\n     * the desired pack level (0..9). The values given below have been tuned to\n     * exclude worst case performance for pathological files. Better values may be\n     * found for specific files.\n     */\n    function zip_DeflateConfiguration(a, b, c, d) {\n        this.good_length = a; // reduce lazy search above this match length\n        this.max_lazy = b;    // do not perform lazy search above this match length\n        this.nice_length = c; // quit search above this match length\n        this.max_chain = d;\n    }\n    \n    function zip_DeflateBuffer() {\n        this.next = null;\n        this.len = 0;\n        this.ptr = new Array(zip_OUTBUFSIZ);\n        this.off = 0;\n    }\n    \n    /* constant tables */\n    var zip_extra_lbits = [\n        0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n    var zip_extra_dbits = [\n        0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n    var zip_extra_blbits = [\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n    var zip_bl_order = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n    var zip_configuration_table = [\n        new zip_DeflateConfiguration(0,    0,   0,    0),\n        new zip_DeflateConfiguration(4,    4,   8,    4),\n        new zip_DeflateConfiguration(4,    5,  16,    8),\n        new zip_DeflateConfiguration(4,    6,  32,   32),\n        new zip_DeflateConfiguration(4,    4,  16,   16),\n        new zip_DeflateConfiguration(8,   16,  32,   32),\n        new zip_DeflateConfiguration(8,   16, 128,  128),\n        new zip_DeflateConfiguration(8,   32, 128,  256),\n        new zip_DeflateConfiguration(32, 128, 258, 1024),\n        new zip_DeflateConfiguration(32, 258, 258, 4096)];\n    \n    \n    /* routines (deflate) */\n    \n    function zip_deflate_start(level) {\n        var i;\n    \n        if(!level)\n        level = zip_DEFAULT_LEVEL;\n        else if(level < 1)\n        level = 1;\n        else if(level > 9)\n        level = 9;\n    \n        zip_compr_level = level;\n        zip_initflag = false;\n        zip_eofile = false;\n        if(zip_outbuf != null)\n        return;\n    \n        zip_free_queue = zip_qhead = zip_qtail = null;\n        zip_outbuf = new Array(zip_OUTBUFSIZ);\n        zip_window = new Array(zip_window_size);\n        zip_d_buf = new Array(zip_DIST_BUFSIZE);\n        zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);\n        zip_prev = new Array(1 << zip_BITS);\n        zip_dyn_ltree = new Array(zip_HEAP_SIZE);\n        for(i = 0; i < zip_HEAP_SIZE; i++)\n        zip_dyn_ltree[i] = new zip_DeflateCT();\n        zip_dyn_dtree = new Array(2*zip_D_CODES+1);\n        for(i = 0; i < 2*zip_D_CODES+1; i++)\n        zip_dyn_dtree[i] = new zip_DeflateCT();\n        zip_static_ltree = new Array(zip_L_CODES+2);\n        for(i = 0; i < zip_L_CODES+2; i++)\n        zip_static_ltree[i] = new zip_DeflateCT();\n        zip_static_dtree = new Array(zip_D_CODES);\n        for(i = 0; i < zip_D_CODES; i++)\n        zip_static_dtree[i] = new zip_DeflateCT();\n        zip_bl_tree = new Array(2*zip_BL_CODES+1);\n        for(i = 0; i < 2*zip_BL_CODES+1; i++)\n        zip_bl_tree[i] = new zip_DeflateCT();\n        zip_l_desc = new zip_DeflateTreeDesc();\n        zip_d_desc = new zip_DeflateTreeDesc();\n        zip_bl_desc = new zip_DeflateTreeDesc();\n        zip_bl_count = new Array(zip_MAX_BITS+1);\n        zip_heap = new Array(2*zip_L_CODES+1);\n        zip_depth = new Array(2*zip_L_CODES+1);\n        zip_length_code = new Array(zip_MAX_MATCH-zip_MIN_MATCH+1);\n        zip_dist_code = new Array(512);\n        zip_base_length = new Array(zip_LENGTH_CODES);\n        zip_base_dist = new Array(zip_D_CODES);\n        zip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));\n    }\n    \n    function zip_deflate_end() {\n        zip_free_queue = zip_qhead = zip_qtail = null;\n        zip_outbuf = null;\n        zip_window = null;\n        zip_d_buf = null;\n        zip_l_buf = null;\n        zip_prev = null;\n        zip_dyn_ltree = null;\n        zip_dyn_dtree = null;\n        zip_static_ltree = null;\n        zip_static_dtree = null;\n        zip_bl_tree = null;\n        zip_l_desc = null;\n        zip_d_desc = null;\n        zip_bl_desc = null;\n        zip_bl_count = null;\n        zip_heap = null;\n        zip_depth = null;\n        zip_length_code = null;\n        zip_dist_code = null;\n        zip_base_length = null;\n        zip_base_dist = null;\n        zip_flag_buf = null;\n    }\n    \n    function zip_reuse_queue(p) {\n        p.next = zip_free_queue;\n        zip_free_queue = p;\n    }\n    \n    function zip_new_queue() {\n        var p;\n    \n        if(zip_free_queue != null)\n        {\n        p = zip_free_queue;\n        zip_free_queue = zip_free_queue.next;\n        }\n        else\n        p = new zip_DeflateBuffer();\n        p.next = null;\n        p.len = p.off = 0;\n    \n        return p;\n    }\n    \n    function zip_head1(i) {\n        return zip_prev[zip_WSIZE + i];\n    }\n    \n    function zip_head2(i, val) {\n        return zip_prev[zip_WSIZE + i] = val;\n    }\n    \n    /* put_byte is used for the compressed output, put_ubyte for the\n     * uncompressed output. However unlzw() uses window for its\n     * suffix table instead of its output buffer, so it does not use put_ubyte\n     * (to be cleaned up).\n     */\n    function zip_put_byte(c) {\n        zip_outbuf[zip_outoff + zip_outcnt++] = c;\n        if(zip_outoff + zip_outcnt == zip_OUTBUFSIZ)\n        zip_qoutbuf();\n    }\n    \n    /* Output a 16 bit value, lsb first */\n    function zip_put_short(w) {\n        w &= 0xffff;\n        if(zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {\n        zip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);\n        zip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);\n        } else {\n        zip_put_byte(w & 0xff);\n        zip_put_byte(w >>> 8);\n        }\n    }\n    \n    /* ==========================================================================\n     * Insert string s in the dictionary and set match_head to the previous head\n     * of the hash chain (the most recent string with same hash key). Return\n     * the previous length of the hash chain.\n     * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n     *    input characters and the first MIN_MATCH bytes of s are valid\n     *    (except for the last MIN_MATCH-1 bytes of the input file).\n     */\n    function zip_INSERT_STRING() {\n        zip_ins_h = ((zip_ins_h << zip_H_SHIFT)\n             ^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))\n        & zip_HASH_MASK;\n        zip_hash_head = zip_head1(zip_ins_h);\n        zip_prev[zip_strstart & zip_WMASK] = zip_hash_head;\n        zip_head2(zip_ins_h, zip_strstart);\n    }\n    \n    /* Send a code of the given tree. c and tree must not have side effects */\n    function zip_SEND_CODE(c, tree) {\n        zip_send_bits(tree[c].fc, tree[c].dl);\n    }\n    \n    /* Mapping from a distance to a distance code. dist is the distance - 1 and\n     * must not have side effects. dist_code[256] and dist_code[257] are never\n     * used.\n     */\n    function zip_D_CODE(dist) {\n        return (dist < 256 ? zip_dist_code[dist]\n            : zip_dist_code[256 + (dist>>7)]) & 0xff;\n    }\n    \n    /* ==========================================================================\n     * Compares to subtrees, using the tree depth as tie breaker when\n     * the subtrees have equal frequency. This minimizes the worst case length.\n     */\n    function zip_SMALLER(tree, n, m) {\n        return tree[n].fc < tree[m].fc ||\n          (tree[n].fc == tree[m].fc && zip_depth[n] <= zip_depth[m]);\n    }\n    \n    /* ==========================================================================\n     * read string data\n     */\n    function zip_read_buff(buff, offset, n) {\n        var i;\n        for(i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++)\n        buff[offset + i] =\n            zip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;\n        return i;\n    }\n    \n    /* ==========================================================================\n     * Initialize the \"longest match\" routines for a new file\n     */\n    function zip_lm_init() {\n        var j;\n    \n        /* Initialize the hash table. */\n        for(j = 0; j < zip_HASH_SIZE; j++)\n    //\tzip_head2(j, zip_NIL);\n        zip_prev[zip_WSIZE + j] = 0;\n        /* prev will be initialized on the fly */\n    \n        /* Set the default configuration parameters:\n         */\n        zip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;\n        zip_good_match     = zip_configuration_table[zip_compr_level].good_length;\n        if(!zip_FULL_SEARCH)\n        zip_nice_match = zip_configuration_table[zip_compr_level].nice_length;\n        zip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;\n    \n        zip_strstart = 0;\n        zip_block_start = 0;\n    \n        zip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);\n        if(zip_lookahead <= 0) {\n        zip_eofile = true;\n        zip_lookahead = 0;\n        return;\n        }\n        zip_eofile = false;\n        /* Make sure that we always have enough lookahead. This is important\n         * if input comes from a device such as a tty.\n         */\n        while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n        zip_fill_window();\n    \n        /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\n         * not important since only literal bytes will be emitted.\n         */\n        zip_ins_h = 0;\n        for(j = 0; j < zip_MIN_MATCH - 1; j++) {\n    //      UPDATE_HASH(ins_h, window[j]);\n        zip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;\n        }\n    }\n    \n    /* ==========================================================================\n     * Set match_start to the longest match starting at the given string and\n     * return its length. Matches shorter or equal to prev_length are discarded,\n     * in which case the result is equal to prev_length and match_start is\n     * garbage.\n     * IN assertions: cur_match is the head of the hash chain for the current\n     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n     */\n    function zip_longest_match(cur_match) {\n        var chain_length = zip_max_chain_length; // max hash chain length\n        var scanp = zip_strstart; // current string\n        var matchp;\t\t// matched string\n        var len;\t\t// length of current match\n        var best_len = zip_prev_length;\t// best match length so far\n    \n        /* Stop when cur_match becomes <= limit. To simplify the code,\n         * we prevent matches with the string of window index 0.\n         */\n        var limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);\n    \n        var strendp = zip_strstart + zip_MAX_MATCH;\n        var scan_end1 = zip_window[scanp + best_len - 1];\n        var scan_end  = zip_window[scanp + best_len];\n    \n        /* Do not waste too much time if we already have a good match: */\n        if(zip_prev_length >= zip_good_match)\n        chain_length >>= 2;\n    \n    //  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\n    \n        do {\n    //    Assert(cur_match < encoder->strstart, \"no future\");\n        matchp = cur_match;\n    \n        /* Skip to next match if the match length cannot increase\n            * or if the match length is less than 2:\n        */\n        if(zip_window[matchp + best_len]\t!= scan_end  ||\n           zip_window[matchp + best_len - 1]\t!= scan_end1 ||\n           zip_window[matchp]\t\t\t!= zip_window[scanp] ||\n           zip_window[++matchp]\t\t\t!= zip_window[scanp + 1]) {\n            continue;\n        }\n    \n        /* The check at best_len-1 can be removed because it will be made\n             * again later. (This heuristic is not always a win.)\n             * It is not necessary to compare scan[2] and match[2] since they\n             * are always equal when the other bytes match, given that\n             * the hash keys are equal and that HASH_BITS >= 8.\n             */\n        scanp += 2;\n        matchp++;\n    \n        /* We check for insufficient lookahead only every 8th comparison;\n             * the 256th check will be made at strstart+258.\n             */\n        do {\n        } while(zip_window[++scanp] == zip_window[++matchp] &&\n            zip_window[++scanp] == zip_window[++matchp] &&\n            zip_window[++scanp] == zip_window[++matchp] &&\n            zip_window[++scanp] == zip_window[++matchp] &&\n            zip_window[++scanp] == zip_window[++matchp] &&\n            zip_window[++scanp] == zip_window[++matchp] &&\n            zip_window[++scanp] == zip_window[++matchp] &&\n            zip_window[++scanp] == zip_window[++matchp] &&\n            scanp < strendp);\n    \n          len = zip_MAX_MATCH - (strendp - scanp);\n          scanp = strendp - zip_MAX_MATCH;\n    \n          if(len > best_len) {\n          zip_match_start = cur_match;\n          best_len = len;\n          if(zip_FULL_SEARCH) {\n              if(len >= zip_MAX_MATCH) break;\n          } else {\n              if(len >= zip_nice_match) break;\n          }\n    \n          scan_end1  = zip_window[scanp + best_len-1];\n          scan_end   = zip_window[scanp + best_len];\n          }\n        } while((cur_match = zip_prev[cur_match & zip_WMASK]) > limit\n            && --chain_length != 0);\n    \n        return best_len;\n    }\n    \n    /* ==========================================================================\n     * Fill the window when the lookahead becomes insufficient.\n     * Updates strstart and lookahead, and sets eofile if end of input file.\n     * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\n     * OUT assertions: at least one byte has been read, or eofile is set;\n     *    file reads are performed for at least two bytes (required for the\n     *    translate_eol option).\n     */\n    function zip_fill_window() {\n        var n, m;\n    \n        // Amount of free space at the end of the window.\n        var more = zip_window_size - zip_lookahead - zip_strstart;\n    \n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n        if(more == -1) {\n        /* Very unlikely, but possible on 16 bit machine if strstart == 0\n             * and lookahead == 1 (input done one byte at time)\n             */\n        more--;\n        } else if(zip_strstart >= zip_WSIZE + zip_MAX_DIST) {\n        /* By the IN assertion, the window is not empty so we can't confuse\n             * more == 0 with more == 64K on a 16 bit machine.\n             */\n    //\tAssert(window_size == (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\n    \n    //\tSystem.arraycopy(window, WSIZE, window, 0, WSIZE);\n        for(n = 0; n < zip_WSIZE; n++)\n            zip_window[n] = zip_window[n + zip_WSIZE];\n          \n        zip_match_start -= zip_WSIZE;\n        zip_strstart    -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */\n        zip_block_start -= zip_WSIZE;\n    \n        for(n = 0; n < zip_HASH_SIZE; n++) {\n            m = zip_head1(n);\n            zip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n        }\n        for(n = 0; n < zip_WSIZE; n++) {\n            /* If n is not on any hash chain, prev[n] is garbage but\n             * its value will never be used.\n             */\n            m = zip_prev[n];\n            zip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n        }\n        more += zip_WSIZE;\n        }\n        // At this point, more >= 2\n        if(!zip_eofile) {\n        n = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);\n        if(n <= 0)\n            zip_eofile = true;\n        else\n            zip_lookahead += n;\n        }\n    }\n    \n    /* ==========================================================================\n     * Processes a new input file and return its compressed length. This\n     * function does not perform lazy evaluationof matches and inserts\n     * new strings in the dictionary only for unmatched strings or for short\n     * matches. It is used only for the fast compression options.\n     */\n    function zip_deflate_fast() {\n        while(zip_lookahead != 0 && zip_qhead == null) {\n        var flush; // set if current block must be flushed\n    \n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        zip_INSERT_STRING();\n    \n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n        if(zip_hash_head != zip_NIL &&\n           zip_strstart - zip_hash_head <= zip_MAX_DIST) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            zip_match_length = zip_longest_match(zip_hash_head);\n            /* longest_match() sets match_start */\n            if(zip_match_length > zip_lookahead)\n            zip_match_length = zip_lookahead;\n        }\n        if(zip_match_length >= zip_MIN_MATCH) {\n    //\t    check_match(strstart, match_start, match_length);\n    \n            flush = zip_ct_tally(zip_strstart - zip_match_start,\n                     zip_match_length - zip_MIN_MATCH);\n            zip_lookahead -= zip_match_length;\n    \n            /* Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             */\n            if(zip_match_length <= zip_max_lazy_match) {\n            zip_match_length--; // string at strstart already in hash table\n            do {\n                zip_strstart++;\n                zip_INSERT_STRING();\n                /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n                 * these bytes are garbage, but it does not matter since\n                 * the next lookahead bytes will be emitted as literals.\n                 */\n            } while(--zip_match_length != 0);\n            zip_strstart++;\n            } else {\n            zip_strstart += zip_match_length;\n            zip_match_length = 0;\n            zip_ins_h = zip_window[zip_strstart] & 0xff;\n    //\t\tUPDATE_HASH(ins_h, window[strstart + 1]);\n            zip_ins_h = ((zip_ins_h<<zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;\n    \n    //#if MIN_MATCH != 3\n    //\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\n    //#endif\n    \n            }\n        } else {\n            /* No match, output a literal byte */\n            flush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);\n            zip_lookahead--;\n            zip_strstart++;\n        }\n        if(flush) {\n            zip_flush_block(0);\n            zip_block_start = zip_strstart;\n        }\n    \n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n            zip_fill_window();\n        }\n    }\n    \n    function zip_deflate_better() {\n        /* Process the input block. */\n        while(zip_lookahead != 0 && zip_qhead == null) {\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        zip_INSERT_STRING();\n    \n        /* Find the longest match, discarding those <= prev_length.\n         */\n        zip_prev_length = zip_match_length;\n        zip_prev_match = zip_match_start;\n        zip_match_length = zip_MIN_MATCH - 1;\n    \n        if(zip_hash_head != zip_NIL &&\n           zip_prev_length < zip_max_lazy_match &&\n           zip_strstart - zip_hash_head <= zip_MAX_DIST) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            zip_match_length = zip_longest_match(zip_hash_head);\n            /* longest_match() sets match_start */\n            if(zip_match_length > zip_lookahead)\n            zip_match_length = zip_lookahead;\n    \n            /* Ignore a length 3 match if it is too distant: */\n            if(zip_match_length == zip_MIN_MATCH &&\n               zip_strstart - zip_match_start > zip_TOO_FAR) {\n            /* If prev_match is also MIN_MATCH, match_start is garbage\n             * but we will ignore the current match anyway.\n             */\n            zip_match_length--;\n            }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if(zip_prev_length >= zip_MIN_MATCH &&\n           zip_match_length <= zip_prev_length) {\n            var flush; // set if current block must be flushed\n    \n    //\t    check_match(strstart - 1, prev_match, prev_length);\n            flush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,\n                     zip_prev_length - zip_MIN_MATCH);\n    \n            /* Insert in hash table all strings up to the end of the match.\n             * strstart-1 and strstart are already inserted.\n             */\n            zip_lookahead -= zip_prev_length - 1;\n            zip_prev_length -= 2;\n            do {\n            zip_strstart++;\n            zip_INSERT_STRING();\n            /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n             * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n             * these bytes are garbage, but it does not matter since the\n             * next lookahead bytes will always be emitted as literals.\n             */\n            } while(--zip_prev_length != 0);\n            zip_match_available = 0;\n            zip_match_length = zip_MIN_MATCH - 1;\n            zip_strstart++;\n            if(flush) {\n            zip_flush_block(0);\n            zip_block_start = zip_strstart;\n            }\n        } else if(zip_match_available != 0) {\n            /* If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             */\n            if(zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {\n            zip_flush_block(0);\n            zip_block_start = zip_strstart;\n            }\n            zip_strstart++;\n            zip_lookahead--;\n        } else {\n            /* There is no previous match to compare with, wait for\n             * the next step to decide.\n             */\n            zip_match_available = 1;\n            zip_strstart++;\n            zip_lookahead--;\n        }\n    \n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n            zip_fill_window();\n        }\n    }\n    \n    function zip_init_deflate() {\n        if(zip_eofile)\n        return;\n        zip_bi_buf = 0;\n        zip_bi_valid = 0;\n        zip_ct_init();\n        zip_lm_init();\n    \n        zip_qhead = null;\n        zip_outcnt = 0;\n        zip_outoff = 0;\n    \n        if(zip_compr_level <= 3)\n        {\n        zip_prev_length = zip_MIN_MATCH - 1;\n        zip_match_length = 0;\n        }\n        else\n        {\n        zip_match_length = zip_MIN_MATCH - 1;\n        zip_match_available = 0;\n        }\n    \n        zip_complete = false;\n    }\n    \n    /* ==========================================================================\n     * Same as above, but achieves better compression. We use a lazy\n     * evaluation for matches: a match is finally adopted only if there is\n     * no better match at the next window position.\n     */\n    function zip_deflate_internal(buff, off, buff_size) {\n        var n;\n    \n        if(!zip_initflag)\n        {\n        zip_init_deflate();\n        zip_initflag = true;\n        if(zip_lookahead == 0) { // empty\n            zip_complete = true;\n            return 0;\n        }\n        }\n    \n        if((n = zip_qcopy(buff, off, buff_size)) == buff_size)\n        return buff_size;\n    \n        if(zip_complete)\n        return n;\n    \n        if(zip_compr_level <= 3) // optimized for speed\n        zip_deflate_fast();\n        else\n        zip_deflate_better();\n        if(zip_lookahead == 0) {\n        if(zip_match_available != 0)\n            zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);\n        zip_flush_block(1);\n        zip_complete = true;\n        }\n        return n + zip_qcopy(buff, n + off, buff_size - n);\n    }\n    \n    function zip_qcopy(buff, off, buff_size) {\n        var n, i, j;\n    \n        n = 0;\n        while(zip_qhead != null && n < buff_size)\n        {\n        i = buff_size - n;\n        if(i > zip_qhead.len)\n            i = zip_qhead.len;\n    //      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\n        for(j = 0; j < i; j++)\n            buff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];\n        \n        zip_qhead.off += i;\n        zip_qhead.len -= i;\n        n += i;\n        if(zip_qhead.len == 0) {\n            var p;\n            p = zip_qhead;\n            zip_qhead = zip_qhead.next;\n            zip_reuse_queue(p);\n        }\n        }\n    \n        if(n == buff_size)\n        return n;\n    \n        if(zip_outoff < zip_outcnt) {\n        i = buff_size - n;\n        if(i > zip_outcnt - zip_outoff)\n            i = zip_outcnt - zip_outoff;\n        // System.arraycopy(outbuf, outoff, buff, off + n, i);\n        for(j = 0; j < i; j++)\n            buff[off + n + j] = zip_outbuf[zip_outoff + j];\n        zip_outoff += i;\n        n += i;\n        if(zip_outcnt == zip_outoff)\n            zip_outcnt = zip_outoff = 0;\n        }\n        return n;\n    }\n    \n    /* ==========================================================================\n     * Allocate the match buffer, initialize the various tables and save the\n     * location of the internal file attribute (ascii/binary) and method\n     * (DEFLATE/STORE).\n     */\n    function zip_ct_init() {\n        var n;\t// iterates over tree elements\n        var bits;\t// bit counter\n        var length;\t// length value\n        var code;\t// code value\n        var dist;\t// distance index\n    \n        if(zip_static_dtree[0].dl != 0) return; // ct_init already called\n    \n        zip_l_desc.dyn_tree\t\t= zip_dyn_ltree;\n        zip_l_desc.static_tree\t= zip_static_ltree;\n        zip_l_desc.extra_bits\t= zip_extra_lbits;\n        zip_l_desc.extra_base\t= zip_LITERALS + 1;\n        zip_l_desc.elems\t\t= zip_L_CODES;\n        zip_l_desc.max_length\t= zip_MAX_BITS;\n        zip_l_desc.max_code\t\t= 0;\n    \n        zip_d_desc.dyn_tree\t\t= zip_dyn_dtree;\n        zip_d_desc.static_tree\t= zip_static_dtree;\n        zip_d_desc.extra_bits\t= zip_extra_dbits;\n        zip_d_desc.extra_base\t= 0;\n        zip_d_desc.elems\t\t= zip_D_CODES;\n        zip_d_desc.max_length\t= zip_MAX_BITS;\n        zip_d_desc.max_code\t\t= 0;\n    \n        zip_bl_desc.dyn_tree\t= zip_bl_tree;\n        zip_bl_desc.static_tree\t= null;\n        zip_bl_desc.extra_bits\t= zip_extra_blbits;\n        zip_bl_desc.extra_base\t= 0;\n        zip_bl_desc.elems\t\t= zip_BL_CODES;\n        zip_bl_desc.max_length\t= zip_MAX_BL_BITS;\n        zip_bl_desc.max_code\t= 0;\n    \n        // Initialize the mapping length (0..255) -> length code (0..28)\n        length = 0;\n        for(code = 0; code < zip_LENGTH_CODES-1; code++) {\n        zip_base_length[code] = length;\n        for(n = 0; n < (1<<zip_extra_lbits[code]); n++)\n            zip_length_code[length++] = code;\n        }\n        // Assert (length == 256, \"ct_init: length != 256\");\n    \n        /* Note that the length 255 (match length 258) can be represented\n         * in two different ways: code 284 + 5 bits or code 285, so we\n         * overwrite length_code[255] to use the best encoding:\n         */\n        zip_length_code[length-1] = code;\n    \n        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n        dist = 0;\n        for(code = 0 ; code < 16; code++) {\n        zip_base_dist[code] = dist;\n        for(n = 0; n < (1<<zip_extra_dbits[code]); n++) {\n            zip_dist_code[dist++] = code;\n        }\n        }\n        // Assert (dist == 256, \"ct_init: dist != 256\");\n        dist >>= 7; // from now on, all distances are divided by 128\n        for( ; code < zip_D_CODES; code++) {\n        zip_base_dist[code] = dist << 7;\n        for(n = 0; n < (1<<(zip_extra_dbits[code]-7)); n++)\n            zip_dist_code[256 + dist++] = code;\n        }\n        // Assert (dist == 256, \"ct_init: 256+dist != 512\");\n    \n        // Construct the codes of the static literal tree\n        for(bits = 0; bits <= zip_MAX_BITS; bits++)\n        zip_bl_count[bits] = 0;\n        n = 0;\n        while(n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n        while(n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }\n        while(n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }\n        while(n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n        /* Codes 286 and 287 do not exist, but we must include them in the\n         * tree construction to get a canonical Huffman tree (longest code\n         * all ones)\n         */\n        zip_gen_codes(zip_static_ltree, zip_L_CODES + 1);\n    \n        /* The static distance tree is trivial: */\n        for(n = 0; n < zip_D_CODES; n++) {\n        zip_static_dtree[n].dl = 5;\n        zip_static_dtree[n].fc = zip_bi_reverse(n, 5);\n        }\n    \n        // Initialize the first block of the first file:\n        zip_init_block();\n    }\n    \n    /* ==========================================================================\n     * Initialize a new block.\n     */\n    function zip_init_block() {\n        var n; // iterates over tree elements\n    \n        // Initialize the trees.\n        for(n = 0; n < zip_L_CODES;  n++) zip_dyn_ltree[n].fc = 0;\n        for(n = 0; n < zip_D_CODES;  n++) zip_dyn_dtree[n].fc = 0;\n        for(n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;\n    \n        zip_dyn_ltree[zip_END_BLOCK].fc = 1;\n        zip_opt_len = zip_static_len = 0;\n        zip_last_lit = zip_last_dist = zip_last_flags = 0;\n        zip_flags = 0;\n        zip_flag_bit = 1;\n    }\n    \n    /* ==========================================================================\n     * Restore the heap property by moving down the tree starting at node k,\n     * exchanging a node with the smallest of its two sons if necessary, stopping\n     * when the heap property is re-established (each father smaller than its\n     * two sons).\n     */\n    function zip_pqdownheap(\n        tree,\t// the tree to restore\n        k) {\t// node to move down\n        var v = zip_heap[k];\n        var j = k << 1;\t// left son of k\n    \n        while(j <= zip_heap_len) {\n        // Set j to the smallest of the two sons:\n        if(j < zip_heap_len &&\n           zip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))\n            j++;\n    \n        // Exit if v is smaller than both sons\n        if(zip_SMALLER(tree, v, zip_heap[j]))\n            break;\n    \n        // Exchange v with the smallest son\n        zip_heap[k] = zip_heap[j];\n        k = j;\n    \n        // And continue down the tree, setting j to the left son of k\n        j <<= 1;\n        }\n        zip_heap[k] = v;\n    }\n    \n    /* ==========================================================================\n     * Compute the optimal bit lengths for a tree and update the total bit length\n     * for the current block.\n     * IN assertion: the fields freq and dad are set, heap[heap_max] and\n     *    above are the tree nodes sorted by increasing frequency.\n     * OUT assertions: the field len is set to the optimal bit length, the\n     *     array bl_count contains the frequencies for each bit length.\n     *     The length opt_len is updated; static_len is also updated if stree is\n     *     not null.\n     */\n    function zip_gen_bitlen(desc) { // the tree descriptor\n        var tree\t\t= desc.dyn_tree;\n        var extra\t\t= desc.extra_bits;\n        var base\t\t= desc.extra_base;\n        var max_code\t= desc.max_code;\n        var max_length\t= desc.max_length;\n        var stree\t\t= desc.static_tree;\n        var h;\t\t// heap index\n        var n, m;\t\t// iterate over the tree elements\n        var bits;\t\t// bit length\n        var xbits;\t\t// extra bits\n        var f;\t\t// frequency\n        var overflow = 0;\t// number of elements with bit length too large\n    \n        for(bits = 0; bits <= zip_MAX_BITS; bits++)\n        zip_bl_count[bits] = 0;\n    \n        /* In a first pass, compute the optimal bit lengths (which may\n         * overflow in the case of the bit length tree).\n         */\n        tree[zip_heap[zip_heap_max]].dl = 0; // root of the heap\n    \n        for(h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {\n        n = zip_heap[h];\n        bits = tree[tree[n].dl].dl + 1;\n        if(bits > max_length) {\n            bits = max_length;\n            overflow++;\n        }\n        tree[n].dl = bits;\n        // We overwrite tree[n].dl which is no longer needed\n    \n        if(n > max_code)\n            continue; // not a leaf node\n    \n        zip_bl_count[bits]++;\n        xbits = 0;\n        if(n >= base)\n            xbits = extra[n - base];\n        f = tree[n].fc;\n        zip_opt_len += f * (bits + xbits);\n        if(stree != null)\n            zip_static_len += f * (stree[n].dl + xbits);\n        }\n        if(overflow == 0)\n        return;\n    \n        // This happens for example on obj2 and pic of the Calgary corpus\n    \n        // Find the first bit length which could increase:\n        do {\n        bits = max_length - 1;\n        while(zip_bl_count[bits] == 0)\n            bits--;\n        zip_bl_count[bits]--;\t\t// move one leaf down the tree\n        zip_bl_count[bits + 1] += 2;\t// move one overflow item as its brother\n        zip_bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n        overflow -= 2;\n        } while(overflow > 0);\n    \n        /* Now recompute all bit lengths, scanning in increasing frequency.\n         * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n         * lengths instead of fixing only the wrong ones. This idea is taken\n         * from 'ar' written by Haruhiko Okumura.)\n         */\n        for(bits = max_length; bits != 0; bits--) {\n        n = zip_bl_count[bits];\n        while(n != 0) {\n            m = zip_heap[--h];\n            if(m > max_code)\n            continue;\n            if(tree[m].dl != bits) {\n            zip_opt_len += (bits - tree[m].dl) * tree[m].fc;\n            tree[m].fc = bits;\n            }\n            n--;\n        }\n        }\n    }\n    \n      /* ==========================================================================\n       * Generate the codes for a given tree and bit counts (which need not be\n       * optimal).\n       * IN assertion: the array bl_count contains the bit length statistics for\n       * the given tree and the field len is set for all tree elements.\n       * OUT assertion: the field code is set for all tree elements of non\n       *     zero code length.\n       */\n    function zip_gen_codes(tree,\t// the tree to decorate\n               max_code) {\t// largest code with non zero frequency\n        var next_code = new Array(zip_MAX_BITS+1); // next code value for each bit length\n        var code = 0;\t\t// running code value\n        var bits;\t\t\t// bit index\n        var n;\t\t\t// code index\n    \n        /* The distribution counts are first used to generate the code values\n         * without bit reversal.\n         */\n        for(bits = 1; bits <= zip_MAX_BITS; bits++) {\n        code = ((code + zip_bl_count[bits-1]) << 1);\n        next_code[bits] = code;\n        }\n    \n        /* Check that the bit counts in bl_count are consistent. The last code\n         * must be all ones.\n         */\n    //    Assert (code + encoder->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n    //\t    \"inconsistent bit counts\");\n    //    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n    \n        for(n = 0; n <= max_code; n++) {\n        var len = tree[n].dl;\n        if(len == 0)\n            continue;\n        // Now reverse the bits\n        tree[n].fc = zip_bi_reverse(next_code[len]++, len);\n    \n    //      Tracec(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //\t  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\n        }\n    }\n    \n    /* ==========================================================================\n     * Construct one Huffman tree and assigns the code bit strings and lengths.\n     * Update the total bit length for the current block.\n     * IN assertion: the field freq is set for all tree elements.\n     * OUT assertions: the fields len and code are set to the optimal bit length\n     *     and corresponding code. The length opt_len is updated; static_len is\n     *     also updated if stree is not null. The field max_code is set.\n     */\n    function zip_build_tree(desc) { // the tree descriptor\n        var tree\t= desc.dyn_tree;\n        var stree\t= desc.static_tree;\n        var elems\t= desc.elems;\n        var n, m;\t\t// iterate over heap elements\n        var max_code = -1;\t// largest code with non zero frequency\n        var node = elems;\t// next internal node of the tree\n    \n        /* Construct the initial heap, with least frequent element in\n         * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n         * heap[0] is not used.\n         */\n        zip_heap_len = 0;\n        zip_heap_max = zip_HEAP_SIZE;\n    \n        for(n = 0; n < elems; n++) {\n        if(tree[n].fc != 0) {\n            zip_heap[++zip_heap_len] = max_code = n;\n            zip_depth[n] = 0;\n        } else\n            tree[n].dl = 0;\n        }\n    \n        /* The pkzip format requires that at least one distance code exists,\n         * and that at least one bit should be sent even if there is only one\n         * possible code. So to avoid special checks later on we force at least\n         * two codes of non zero frequency.\n         */\n        while(zip_heap_len < 2) {\n        var xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);\n        tree[xnew].fc = 1;\n        zip_depth[xnew] = 0;\n        zip_opt_len--;\n        if(stree != null)\n            zip_static_len -= stree[xnew].dl;\n        // new is 0 or 1 so it does not have extra bits\n        }\n        desc.max_code = max_code;\n    \n        /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n         * establish sub-heaps of increasing lengths:\n         */\n        for(n = zip_heap_len >> 1; n >= 1; n--)\n        zip_pqdownheap(tree, n);\n    \n        /* Construct the Huffman tree by repeatedly combining the least two\n         * frequent nodes.\n         */\n        do {\n        n = zip_heap[zip_SMALLEST];\n        zip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];\n        zip_pqdownheap(tree, zip_SMALLEST);\n    \n        m = zip_heap[zip_SMALLEST];  // m = node of next least frequency\n    \n        // keep the nodes sorted by frequency\n        zip_heap[--zip_heap_max] = n;\n        zip_heap[--zip_heap_max] = m;\n    \n        // Create a new node father of n and m\n        tree[node].fc = tree[n].fc + tree[m].fc;\n    //\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\n        if(zip_depth[n] > zip_depth[m] + 1)\n            zip_depth[node] = zip_depth[n];\n        else\n            zip_depth[node] = zip_depth[m] + 1;\n        tree[n].dl = tree[m].dl = node;\n    \n        // and insert the new node in the heap\n        zip_heap[zip_SMALLEST] = node++;\n        zip_pqdownheap(tree, zip_SMALLEST);\n    \n        } while(zip_heap_len >= 2);\n    \n        zip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];\n    \n        /* At this point, the fields freq and dad are set. We can now\n         * generate the bit lengths.\n         */\n        zip_gen_bitlen(desc);\n    \n        // The field len is now set, we can generate the bit codes\n        zip_gen_codes(tree, max_code);\n    }\n    \n    /* ==========================================================================\n     * Scan a literal or distance tree to determine the frequencies of the codes\n     * in the bit length tree. Updates opt_len to take into account the repeat\n     * counts. (The contribution of the bit length codes will be added later\n     * during the construction of bl_tree.)\n     */\n    function zip_scan_tree(tree,// the tree to be scanned\n                   max_code) {  // and its largest code of non zero frequency\n        var n;\t\t\t// iterates over all tree elements\n        var prevlen = -1;\t\t// last emitted length\n        var curlen;\t\t\t// length of current code\n        var nextlen = tree[0].dl;\t// length of next code\n        var count = 0;\t\t// repeat count of the current code\n        var max_count = 7;\t\t// max repeat count\n        var min_count = 4;\t\t// min repeat count\n    \n        if(nextlen == 0) {\n        max_count = 138;\n        min_count = 3;\n        }\n        tree[max_code + 1].dl = 0xffff; // guard\n    \n        for(n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[n + 1].dl;\n        if(++count < max_count && curlen == nextlen)\n            continue;\n        else if(count < min_count)\n            zip_bl_tree[curlen].fc += count;\n        else if(curlen != 0) {\n            if(curlen != prevlen)\n            zip_bl_tree[curlen].fc++;\n            zip_bl_tree[zip_REP_3_6].fc++;\n        } else if(count <= 10)\n            zip_bl_tree[zip_REPZ_3_10].fc++;\n        else\n            zip_bl_tree[zip_REPZ_11_138].fc++;\n        count = 0; prevlen = curlen;\n        if(nextlen == 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if(curlen == nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n        }\n    }\n    \n      /* ==========================================================================\n       * Send a literal or distance tree in compressed form, using the codes in\n       * bl_tree.\n       */\n    function zip_send_tree(tree, // the tree to be scanned\n               max_code) { // and its largest code of non zero frequency\n        var n;\t\t\t// iterates over all tree elements\n        var prevlen = -1;\t\t// last emitted length\n        var curlen;\t\t\t// length of current code\n        var nextlen = tree[0].dl;\t// length of next code\n        var count = 0;\t\t// repeat count of the current code\n        var max_count = 7;\t\t// max repeat count\n        var min_count = 4;\t\t// min repeat count\n    \n        /* tree[max_code+1].dl = -1; */  /* guard already set */\n        if(nextlen == 0) {\n          max_count = 138;\n          min_count = 3;\n        }\n    \n        for(n = 0; n <= max_code; n++) {\n        curlen = nextlen;\n        nextlen = tree[n+1].dl;\n        if(++count < max_count && curlen == nextlen) {\n            continue;\n        } else if(count < min_count) {\n            do { zip_SEND_CODE(curlen, zip_bl_tree); } while(--count != 0);\n        } else if(curlen != 0) {\n            if(curlen != prevlen) {\n            zip_SEND_CODE(curlen, zip_bl_tree);\n            count--;\n            }\n            // Assert(count >= 3 && count <= 6, \" 3_6?\");\n            zip_SEND_CODE(zip_REP_3_6, zip_bl_tree);\n            zip_send_bits(count - 3, 2);\n        } else if(count <= 10) {\n            zip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);\n            zip_send_bits(count-3, 3);\n        } else {\n            zip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);\n            zip_send_bits(count-11, 7);\n        }\n        count = 0;\n        prevlen = curlen;\n        if(nextlen == 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if(curlen == nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n        }\n    }\n    \n    /* ==========================================================================\n     * Construct the Huffman tree for the bit lengths and return the index in\n     * bl_order of the last bit length code to send.\n     */\n    function zip_build_bl_tree() {\n        var max_blindex;  // index of last bit length code of non zero freq\n    \n        // Determine the bit length frequencies for literal and distance trees\n        zip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);\n        zip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);\n    \n        // Build the bit length tree:\n        zip_build_tree(zip_bl_desc);\n        /* opt_len now includes the length of the tree representations, except\n         * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n         */\n    \n        /* Determine the number of bit length codes to send. The pkzip format\n         * requires that at least 4 bit length codes be sent. (appnote.txt says\n         * 3 but the actual value used is 4.)\n         */\n        for(max_blindex = zip_BL_CODES-1; max_blindex >= 3; max_blindex--) {\n        if(zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;\n        }\n        /* Update opt_len to include the bit length tree and counts */\n        zip_opt_len += 3*(max_blindex+1) + 5+5+4;\n    //    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n    //\t    encoder->opt_len, encoder->static_len));\n    \n        return max_blindex;\n    }\n    \n    /* ==========================================================================\n     * Send the header for a block using dynamic Huffman trees: the counts, the\n     * lengths of the bit length codes, the literal tree and the distance tree.\n     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n     */\n    function zip_send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree\n        var rank; // index in bl_order\n    \n    //    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    //    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n    //\t    \"too many codes\");\n    //    Tracev((stderr, \"\\nbl counts: \"));\n        zip_send_bits(lcodes-257, 5); // not +255 as stated in appnote.txt\n        zip_send_bits(dcodes-1,   5);\n        zip_send_bits(blcodes-4,  4); // not -3 as stated in appnote.txt\n        for(rank = 0; rank < blcodes; rank++) {\n    //      Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        zip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);\n        }\n    \n        // send the literal tree\n        zip_send_tree(zip_dyn_ltree,lcodes-1);\n    \n        // send the distance tree\n        zip_send_tree(zip_dyn_dtree,dcodes-1);\n    }\n    \n    /* ==========================================================================\n     * Determine the best encoding for the current block: dynamic trees, static\n     * trees or store, and output the encoded block to the zip file.\n     */\n    function zip_flush_block(eof) { // true if this is the last block for a file\n        var opt_lenb, static_lenb; // opt_len and static_len in bytes\n        var max_blindex;\t// index of last bit length code of non zero freq\n        var stored_len;\t// length of input block\n    \n        stored_len = zip_strstart - zip_block_start;\n        zip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items\n    \n        // Construct the literal and distance trees\n        zip_build_tree(zip_l_desc);\n    //    Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\n    //\t    encoder->opt_len, encoder->static_len));\n    \n        zip_build_tree(zip_d_desc);\n    //    Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\n    //\t    encoder->opt_len, encoder->static_len));\n        /* At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         */\n    \n        /* Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         */\n        max_blindex = zip_build_bl_tree();\n    \n        // Determine the best encoding. Compute first the block length in bytes\n        opt_lenb\t= (zip_opt_len   +3+7)>>3;\n        static_lenb = (zip_static_len+3+7)>>3;\n    \n    //    Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\n    //\t   opt_lenb, encoder->opt_len,\n    //\t   static_lenb, encoder->static_len, stored_len,\n    //\t   encoder->last_lit, encoder->last_dist));\n    \n        if(static_lenb <= opt_lenb)\n        opt_lenb = static_lenb;\n        if(stored_len + 4 <= opt_lenb // 4: two words for the lengths\n           && zip_block_start >= 0) {\n        var i;\n    \n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        zip_send_bits((zip_STORED_BLOCK<<1)+eof, 3);  /* send block type */\n        zip_bi_windup();\t\t /* align on byte boundary */\n        zip_put_short(stored_len);\n        zip_put_short(~stored_len);\n    \n          // copy block\n    /*\n          p = &window[block_start];\n          for(i = 0; i < stored_len; i++)\n        put_byte(p[i]);\n    */\n        for(i = 0; i < stored_len; i++)\n            zip_put_byte(zip_window[zip_block_start + i]);\n    \n        } else if(static_lenb == opt_lenb) {\n        zip_send_bits((zip_STATIC_TREES<<1)+eof, 3);\n        zip_compress_block(zip_static_ltree, zip_static_dtree);\n        } else {\n        zip_send_bits((zip_DYN_TREES<<1)+eof, 3);\n        zip_send_all_trees(zip_l_desc.max_code+1,\n                   zip_d_desc.max_code+1,\n                   max_blindex+1);\n        zip_compress_block(zip_dyn_ltree, zip_dyn_dtree);\n        }\n    \n        zip_init_block();\n    \n        if(eof != 0)\n        zip_bi_windup();\n    }\n    \n    /* ==========================================================================\n     * Save the match info and tally the frequency counts. Return true if\n     * the current block must be flushed.\n     */\n    function zip_ct_tally(\n        dist, // distance of matched string\n        lc) { // match length-MIN_MATCH or unmatched char (if dist==0)\n        zip_l_buf[zip_last_lit++] = lc;\n        if(dist == 0) {\n        // lc is the unmatched char\n        zip_dyn_ltree[lc].fc++;\n        } else {\n        // Here, lc is the match length - MIN_MATCH\n        dist--;\t\t    // dist = match distance - 1\n    //      Assert((ush)dist < (ush)MAX_DIST &&\n    //\t     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //\t     (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\n    \n        zip_dyn_ltree[zip_length_code[lc]+zip_LITERALS+1].fc++;\n        zip_dyn_dtree[zip_D_CODE(dist)].fc++;\n    \n        zip_d_buf[zip_last_dist++] = dist;\n        zip_flags |= zip_flag_bit;\n        }\n        zip_flag_bit <<= 1;\n    \n        // Output the flags if they fill a byte\n        if((zip_last_lit & 7) == 0) {\n        zip_flag_buf[zip_last_flags++] = zip_flags;\n        zip_flags = 0;\n        zip_flag_bit = 1;\n        }\n        // Try to guess if it is profitable to stop the current block here\n        if(zip_compr_level > 2 && (zip_last_lit & 0xfff) == 0) {\n        // Compute an upper bound for the compressed length\n        var out_length = zip_last_lit * 8;\n        var in_length = zip_strstart - zip_block_start;\n        var dcode;\n    \n        for(dcode = 0; dcode < zip_D_CODES; dcode++) {\n            out_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);\n        }\n        out_length >>= 3;\n    //      Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\n    //\t     encoder->last_lit, encoder->last_dist, in_length, out_length,\n    //\t     100L - out_length*100L/in_length));\n        if(zip_last_dist < parseInt(zip_last_lit/2) &&\n           out_length < parseInt(in_length/2))\n            return true;\n        }\n        return (zip_last_lit == zip_LIT_BUFSIZE-1 ||\n            zip_last_dist == zip_DIST_BUFSIZE);\n        /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n         * on 16 bit machines and because stored blocks are restricted to\n         * 64K-1 bytes.\n         */\n    }\n    \n      /* ==========================================================================\n       * Send the block data compressed using the given Huffman trees\n       */\n    function zip_compress_block(\n        ltree,\t// literal tree\n        dtree) {\t// distance tree\n        var dist;\t\t// distance of matched string\n        var lc;\t\t// match length or unmatched char (if dist == 0)\n        var lx = 0;\t\t// running index in l_buf\n        var dx = 0;\t\t// running index in d_buf\n        var fx = 0;\t\t// running index in flag_buf\n        var flag = 0;\t// current flags\n        var code;\t\t// the code to send\n        var extra;\t\t// number of extra bits to send\n    \n        if(zip_last_lit != 0) do {\n        if((lx & 7) == 0)\n            flag = zip_flag_buf[fx++];\n        lc = zip_l_buf[lx++] & 0xff;\n        if((flag & 1) == 0) {\n            zip_SEND_CODE(lc, ltree); /* send a literal byte */\n    //\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n            // Here, lc is the match length - MIN_MATCH\n            code = zip_length_code[lc];\n            zip_SEND_CODE(code+zip_LITERALS+1, ltree); // send the length code\n            extra = zip_extra_lbits[code];\n            if(extra != 0) {\n            lc -= zip_base_length[code];\n            zip_send_bits(lc, extra); // send the extra length bits\n            }\n            dist = zip_d_buf[dx++];\n            // Here, dist is the match distance - 1\n            code = zip_D_CODE(dist);\n    //\tAssert (code < D_CODES, \"bad d_code\");\n    \n            zip_SEND_CODE(code, dtree);\t  // send the distance code\n            extra = zip_extra_dbits[code];\n            if(extra != 0) {\n            dist -= zip_base_dist[code];\n            zip_send_bits(dist, extra);   // send the extra distance bits\n            }\n        } // literal or match pair ?\n        flag >>= 1;\n        } while(lx < zip_last_lit);\n    \n        zip_SEND_CODE(zip_END_BLOCK, ltree);\n    }\n    \n    /* ==========================================================================\n     * Send a value on a given number of bits.\n     * IN assertion: length <= 16 and value fits in length bits.\n     */\n    var zip_Buf_size = 16; // bit size of bi_buf\n    function zip_send_bits(\n        value,\t// value to send\n        length) {\t// number of bits\n        /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n         * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n         * unused bits in value.\n         */\n        if(zip_bi_valid > zip_Buf_size - length) {\n        zip_bi_buf |= (value << zip_bi_valid);\n        zip_put_short(zip_bi_buf);\n        zip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));\n        zip_bi_valid += length - zip_Buf_size;\n        } else {\n        zip_bi_buf |= value << zip_bi_valid;\n        zip_bi_valid += length;\n        }\n    }\n    \n    /* ==========================================================================\n     * Reverse the first len bits of a code, using straightforward code (a faster\n     * method would use a table)\n     * IN assertion: 1 <= len <= 15\n     */\n    function zip_bi_reverse(\n        code,\t// the value to invert\n        len) {\t// its bit length\n        var res = 0;\n        do {\n        res |= code & 1;\n        code >>= 1;\n        res <<= 1;\n        } while(--len > 0);\n        return res >> 1;\n    }\n    \n    /* ==========================================================================\n     * Write out any remaining bits in an incomplete byte.\n     */\n    function zip_bi_windup() {\n        if(zip_bi_valid > 8) {\n        zip_put_short(zip_bi_buf);\n        } else if(zip_bi_valid > 0) {\n        zip_put_byte(zip_bi_buf);\n        }\n        zip_bi_buf = 0;\n        zip_bi_valid = 0;\n    }\n    \n    function zip_qoutbuf() {\n        if(zip_outcnt != 0) {\n        var q, i;\n        q = zip_new_queue();\n        if(zip_qhead == null)\n            zip_qhead = zip_qtail = q;\n        else\n            zip_qtail = zip_qtail.next = q;\n        q.len = zip_outcnt - zip_outoff;\n    //      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);\n        for(i = 0; i < q.len; i++)\n            q.ptr[i] = zip_outbuf[zip_outoff + i];\n        zip_outcnt = zip_outoff = 0;\n        }\n    }\n    \n    return function deflate(str, level) {\n        var i, j;\n    \n        zip_deflate_data = str;\n        zip_deflate_pos = 0;\n        if(typeof level == \"undefined\")\n        level = zip_DEFAULT_LEVEL;\n        zip_deflate_start(level);\n    \n        var buff = new Array(1024);\n        var aout = [];\n        while((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {\n        var cbuf = new Array(i);\n        for(j = 0; j < i; j++){\n            cbuf[j] = String.fromCharCode(buff[j]);\n        }\n        aout[aout.length] = cbuf.join(\"\");\n        }\n        zip_deflate_data = null; // G.C.\n        return aout.join(\"\");\n    };\n    \n    })();\n    \n    var onmessage = function worker(m) {\n      postMessage(deflate(m.data, 9));\n    };\n    \n    var onconnect = function sharedWorker(e) {\n      var port = e.ports[0];\n      port.onmessage = function(m) {\n        port.postMessage(deflate(m.data, 9));\n      };\n    };\n    \n    module.exports = deflate;","import React, { Component } from 'react';\n\nexport default ({recover, isto}) => {\n    return (\n        <ul>\n            {\n                isto.list(10).map((val, index) => {\n                    return <li key={index}><button onClick={ () => recover(val) } >History Item {index}: {val.label}</button></li>\n                })\n            }\n        </ul>\n    )\n}","import React, { Component } from 'react';\n\nimport \"./App.css\"\n\nimport History from \"./History\"\nimport { compress } from \"./encode\"\n\nimport { isto } from \"istoryh\"\n\nclass App extends Component {\n\n  constructor(props) {\n    super(props)\n    const ueIsto = isto(10, \"ueisto\");\n    this.state = {\n      source: \"Bob -> Alice : Hello\",\n      label: \"default\",\n      img: \"http://www.plantuml.com/plantuml/img/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000\",\n      ...ueIsto.top(),\n      ueIsto\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"App-flex1 App-flexCol\">\n          <textarea\n            onChange={(event) => this.onTextChangeUpdate(event.target.value)}\n            value={this.state.source}\n            cols={80}\n            rows={44}\n          />\n          <button onClick={this.onSaveButtonClick} style={{ width: 140 }}>Save History</button>\n          <History recover={this.onRecoverEditingText} isto={this.state.ueIsto} />\n        </div>\n        <div className=\"App-flex3\">\n          <img alt={this.state.label} src={this.state.img} />\n        </div>\n      </div>\n    );\n  }\n\n  onTextChangeUpdate = (source) => {\n    const state = {\n      source,\n      img: `http://www.plantuml.com/plantuml/img/${compress(source)}`,\n      label: new Date().toLocaleString()\n    }\n\n    this.setState(state);\n  }\n\n  onSaveButtonClick = () => {\n    const { source, img, label } = this.state;\n    this.state.ueIsto.push({ source, img, label });\n    this.setState({});\n  }\n\n  onRecoverEditingText = (state) => {\n    this.setState({ ...state })\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}